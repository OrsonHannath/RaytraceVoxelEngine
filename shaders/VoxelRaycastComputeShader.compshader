#version 440 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

// Custom Structures
struct Voxel{
    int type;
};

struct WorldSettings{
    int chunkSize;
    int renderDistance;
    int totalSize;
};

struct Camera{
    float posX, posY, posZ;
    float dirX, dirY, dirZ;
    float rightX, rightY, rightZ;
    float upX, upY, upZ;
    float aspectRatio;
    float fov;
};

struct Light{
    float posX, posY, posZ;
    float colR, colG, colB, colA;
    float intensity;
    float size;
    bool global;
};

// Pass in Camera Information
layout(binding = 1) buffer camera_data {

    Camera cameras[];
};

// Pass in Lighting Information
layout(binding = 2) buffer world_lights {

    Light lights[];
};

// Pass in the Voxel Indices Array
layout(binding = 3) buffer world_voxel_indices {

    int voxel_indices[];
};

// Pass in the Voxel Data Array
layout(binding = 4) buffer world_voxel_data {

    Voxel world_voxels[];
};

// Pass in the world settings
layout(binding = 5) buffer world_settings {

    WorldSettings worldSettings[];
};

int FlatIndex(int x, int y, int z){

    // Make sure in bounds positive
    if(x >= worldSettings[0].totalSize || y >= worldSettings[0].totalSize || z >= worldSettings[0].totalSize){
        return -1;
    }

    // Makes sure in bounds negative
    if(x < 0 || y < 0 || z < 0){
        return -1;
    }

    return (z * worldSettings[0].totalSize * worldSettings[0].totalSize) + (y * worldSettings[0].totalSize) + x;
}

int GetVoxelIndex(int x, int y, int z){

    int index = FlatIndex(x, y, z);
    if(index >= 0 && index < voxel_indices.length()){

        return voxel_indices[FlatIndex(x, y, z)];
    }

    return -1;
}

bool IsAirVoxel(int x, int y, int z){

    if(world_voxels[GetVoxelIndex(x, y, z)].type == 0){
        return true;
    }

    return false;
}

bool IsVoxelAt(int x, int y, int z){

    // Check if there is a voxel at the given coordinates
    if(GetVoxelIndex(x, y, z) != -1 && !IsAirVoxel(x, y, z)){

        return true;
    }

    return false;
}

Voxel GetVoxelAt(int x, int y, int z){

    if(IsVoxelAt(x, y, z)){

        return world_voxels[GetVoxelIndex(x, y, z)];
    }

    return Voxel(-1);
}

void main() {

    // Set a default pixel color and obtain pixel coordinates
    vec4 pixel = vec4(0.075, 0.133, 0.173, 1.0);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    // Obtain the camera position and orientation
    vec3 cam_o = vec3(cameras[0].posX, cameras[0].posY, cameras[0].posZ);
    vec3 cam_right = vec3(cameras[0].rightX, cameras[0].rightY, cameras[0].rightZ);
    vec3 cam_up = vec3(cameras[0].upX, cameras[0].upY, cameras[0].upZ);
    vec3 cam_dir = vec3(cameras[0].dirX, cameras[0].dirY, cameras[0].dirZ);

    ivec2 dims = imageSize(screen);

    // Adjust x and y for the aspect ratio
    float aspectRatio = float(dims.x) / float(dims.y);
    float x = (float(pixel_coords.x * 2 - dims.x) / dims.x) * aspectRatio;
    float y = float(pixel_coords.y * 2 - dims.y) / dims.y;

    // Define FOV in radians (for example, 60 degrees)
    float fov = radians(cameras[0].fov); // Change the FOV value as needed

    // Calculate the view space ray direction
    float tanFov = tan(fov * 0.5);
    vec3 rightDir = normalize(cam_right) * x * tanFov;
    vec3 upDir = normalize(cam_up) * y * tanFov;
    vec3 ray_d = normalize(cam_dir + rightDir + upDir);

    // Calculate the point on the screen in the world space
    vec3 ray_o = cam_o;

    // Raycasting
    vec3 pos = floor(ray_o);
    vec3 step = sign(ray_d);
    vec3 tDelta = step / ray_d;
    float tMaxX, tMaxY, tMaxZ;
    vec3 fr = fract(ray_o);

    tMaxX = tDelta.x * ((ray_d.x>0.0) ? (1.0 - fr.x) : fr.x);
    tMaxY = tDelta.y * ((ray_d.y>0.0) ? (1.0 - fr.y) : fr.y);
    tMaxZ = tDelta.z * ((ray_d.z>0.0) ? (1.0 - fr.z) : fr.z);

    vec3 norm;
    const int maxTrace = 1000;

    for (int i = 0; i < maxTrace; i++) {

        if (tMaxX < tMaxY) {
            if (tMaxZ < tMaxX) {
                tMaxZ += tDelta.z;
                pos.z += step.z;
                norm = vec3(0, 0,-step.z);
            } else {
                tMaxX += tDelta.x;
                pos.x += step.x;
                norm = vec3(-step.x, 0, 0);
            }
        } else {
            if (tMaxZ < tMaxY) {
                tMaxZ += tDelta.z;
                pos.z += step.z;
                norm = vec3(0, 0, -step.z);
            } else {
                tMaxY += tDelta.y;
                pos.y += step.y;
                norm = vec3(0, -step.y, 0);
            }
        }

        // Check if there is a voxel at the position
        if(IsVoxelAt(int(pos.x), int(pos.y), int(pos.z))){

            pixel = vec4(GetVoxelAt(int(pos.x), int(pos.y), int(pos.z)).type / 255.0, GetVoxelAt(int(pos.x), int(pos.y), int(pos.z)).type / 255.0, GetVoxelAt(int(pos.x), int(pos.y), int(pos.z)).type / 255.0, 1);
            break;
        }
    }

    imageStore(screen, pixel_coords, pixel);
}