#version 440 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

// Custom Structures
struct Voxel{
    int type;
};

struct WorldSettings{
    int octreeDepth;
    int worldScale;
};

struct Camera{
    float posX, posY, posZ;
    float dirX, dirY, dirZ;
    float rightX, rightY, rightZ;
    float upX, upY, upZ;
    float aspectRatio;
    float fov;
};

struct Light{
    float posX, posY, posZ;
    float colR, colG, colB, colA;
    float intensity;
    float size;
    bool global;
};

struct RayHit{
    bool hit;
    float distance;
};

// Pass in Camera Information
layout(binding = 1) buffer camera_data {

    Camera cameras[];
};

// Pass in Lighting Information
layout(binding = 2) buffer world_lights {

    Light lights[];
};

// Pass in the Voxel Indices Array
layout(binding = 3) buffer world_voxel_indices {

    int voxel_indices[];
};

// Pass in the Voxel Data Array
layout(binding = 4) buffer world_voxel_data {

    Voxel world_voxels[];
};

// Pass in the world settings
layout(binding = 5) buffer world_settings {

    WorldSettings worldSettings[];
};

// https://tavianator.com/2022/ray_box_boundary.html
RayHit RayIntersect(vec3 rayOrigin, vec3 rayDirection, vec3 voxelPosition, float octantScale){

    // Calculate the voxels bounding positions, i.e., two opposing corners of the voxel
    vec3 voxelMin = voxelPosition;
    vec3 voxelMax = voxelPosition + vec3(octantScale);

    vec3 invRayDirection = 1.0 / rayDirection;

    float tmin = 0.0, tmax = (1.0/0.0);

    for (int d = 0; d < 3; ++d) {
        float t1 = (voxelMin[d] - rayOrigin[d]) * invRayDirection[d];
        float t2 = (voxelMax[d] - rayOrigin[d]) * invRayDirection[d];

        tmin = max(tmin, min(t1, t2));
        tmax = min(tmax, max(t1, t2));
    }

    RayHit rayHit = {false, 0};
    if(tmin < tmax){
        rayHit.hit = true;
        rayHit.distance = tmin;
    }
    return rayHit;
}

void main() {

    // Set a default pixel color and obtain pixel coordinates
    vec4 pixel = vec4(0.075, 0.133, 0.173, 1.0);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    // Obtain the camera position and orientation
    vec3 cam_o = vec3(cameras[0].posX, cameras[0].posY, cameras[0].posZ);
    vec3 cam_right = vec3(cameras[0].rightX, cameras[0].rightY, cameras[0].rightZ);
    vec3 cam_up = vec3(cameras[0].upX, cameras[0].upY, cameras[0].upZ);
    vec3 cam_dir = vec3(cameras[0].dirX, cameras[0].dirY, cameras[0].dirZ);

    ivec2 dims = imageSize(screen);

    // Adjust x and y for the aspect ratio
    float aspectRatio = float(dims.x) / float(dims.y);
    float x = (float(pixel_coords.x * 2 - dims.x) / dims.x) * aspectRatio;
    float y = float(pixel_coords.y * 2 - dims.y) / dims.y;

    // Define FOV in radians (for example, 60 degrees)
    float fov = radians(cameras[0].fov); // Change the FOV value as needed

    // Calculate the view space ray direction
    float tanFov = tan(fov * 0.5);
    vec3 rightDir = normalize(cam_right) * x * tanFov;
    vec3 upDir = normalize(cam_up) * y * tanFov;
    vec3 ray_d = normalize(cam_dir + rightDir + upDir);

    // Calculate the point on the screen in the world space
    vec3 ray_o = cam_o;

    // The positional relationship of each child in the octree
    vec3 childRelations[] = {vec3(0,0,0), vec3(0,0,1), vec3(0,1,0), vec3(0,1,1), vec3(1,0,0), vec3(1,0,1), vec3(1,1,0), vec3(1,1,1)};

    // Variables to hold the child that was hit closest
    float minHitDistance = (1.0/0.0);
    int minHitChild = -1;
    bool intersectFound = false;

    int hitcount = 0;

    // Check for intersection of the ray within the octree
    int scale = worldSettings[0].worldScale;
    int octreeDepth = worldSettings[0].octreeDepth; // The maximum depth of the octree (should be set as a buffer object)
    vec3 parentVoxelPosition = vec3(0, 0, 0);
    for(int i = 0; i < octreeDepth; i++){

        // Hit this octant
        bool octantHit = false;

        // The scale of the octant at this position
        float octantScale = scale * (1/pow(2, i));

        // Check if the ray will intersect with any of the child voxels
        for(int j = 0; j < 8; j++){

            vec3 voxelPosition = parentVoxelPosition + (childRelations[j] * octantScale);  // Voxel is located at the origin
            RayHit rayHit = RayIntersect(ray_o, ray_d, voxelPosition, octantScale);

            // Update the parent voxels position to be that of the hit voxel
            if(rayHit.hit){

                // If this is the first hit for this octant then reset the minimum values
                if(!octantHit){
                    octantHit = true;
                    minHitDistance = (1.0/0.0);
                    minHitChild = -1;
                    intersectFound = false;
                }

                if(rayHit.distance < minHitDistance){
                    minHitDistance = rayHit.distance;
                    minHitChild = j;
                    intersectFound = true;
                }

                hitcount = hitcount + 1;
            }
        }

        if(octantHit){
            parentVoxelPosition = parentVoxelPosition + (childRelations[minHitChild] * octantScale);
        }
    }

    if(intersectFound){
        // Render the closest hit child
        pixel = vec4(hitcount/40.0);
        //pixel = vec4(parentVoxelPosition.x/float(scale*2), parentVoxelPosition.y/float(scale*2), parentVoxelPosition.z/float(scale*2), 1);
    }

    imageStore(screen, pixel_coords, pixel);
}